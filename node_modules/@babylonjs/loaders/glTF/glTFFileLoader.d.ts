import * as GLTF2 from "babylonjs-gltf2interface";
import { Nullable } from "@babylonjs/core/types";
import { Observable } from "@babylonjs/core/Misc/observable";
import { Camera } from "@babylonjs/core/Cameras/camera";
import { AnimationGroup } from "@babylonjs/core/Animations/animationGroup";
import { Skeleton } from "@babylonjs/core/Bones/skeleton";
import { IParticleSystem } from "@babylonjs/core/Particles/IParticleSystem";
import { BaseTexture } from "@babylonjs/core/Materials/Textures/baseTexture";
import { Material } from "@babylonjs/core/Materials/material";
import { AbstractMesh } from "@babylonjs/core/Meshes/abstractMesh";
import { ISceneLoaderPluginFactory, ISceneLoaderPlugin, ISceneLoaderPluginAsync, SceneLoaderProgressEvent, ISceneLoaderPluginExtensions } from "@babylonjs/core/Loading/sceneLoader";
import { AssetContainer } from "@babylonjs/core/assetContainer";
import { Scene, IDisposable } from "@babylonjs/core/scene";
import { WebRequest } from "@babylonjs/core/Misc/webRequest";
import { IFileRequest } from "@babylonjs/core/Misc/fileRequest";
import { IDataBuffer } from '@babylonjs/core/Misc/dataReader';
import { Light } from '@babylonjs/core/Lights/light';
import { TransformNode } from '@babylonjs/core/Meshes/transformNode';
/**
 * Mode that determines the coordinate system to use.
 */
export declare enum GLTFLoaderCoordinateSystemMode {
    /**
     * Automatically convert the glTF right-handed data to the appropriate system based on the current coordinate system mode of the scene.
     */
    AUTO = 0,
    /**
     * Sets the useRightHandedSystem flag on the scene.
     */
    FORCE_RIGHT_HANDED = 1
}
/**
 * Mode that determines what animations will start.
 */
export declare enum GLTFLoaderAnimationStartMode {
    /**
     * No animation will start.
     */
    NONE = 0,
    /**
     * The first animation will start.
     */
    FIRST = 1,
    /**
     * All animations will start.
     */
    ALL = 2
}
/**
 * Interface that contains the data for the glTF asset.
 */
export interface IGLTFLoaderData {
    /**
     * The object that represents the glTF JSON.
     */
    json: Object;
    /**
     * The BIN chunk of a binary glTF.
     */
    bin: Nullable<IDataBuffer>;
}
/**
 * Interface for extending the loader.
 */
export interface IGLTFLoaderExtension {
    /**
     * The name of this extension.
     */
    readonly name: string;
    /**
     * Defines whether this extension is enabled.
     */
    enabled: boolean;
    /**
     * Defines the order of this extension.
     * The loader sorts the extensions using these values when loading.
     */
    order?: number;
}
/**
 * Loader state.
 */
export declare enum GLTFLoaderState {
    /**
     * The asset is loading.
     */
    LOADING = 0,
    /**
     * The asset is ready for rendering.
     */
    READY = 1,
    /**
     * The asset is completely loaded.
     */
    COMPLETE = 2
}
/** @hidden */
export interface IImportMeshAsyncOutput {
    meshes: AbstractMesh[];
    particleSystems: IParticleSystem[];
    skeletons: Skeleton[];
    animationGroups: AnimationGroup[];
    lights: Light[];
    transformNodes: TransformNode[];
}
/** @hidden */
export interface IGLTFLoader extends IDisposable {
    readonly state: Nullable<GLTFLoaderState>;
    importMeshAsync: (meshesNames: any, scene: Scene, forAssetContainer: boolean, data: IGLTFLoaderData, rootUrl: string, onProgress?: (event: SceneLoaderProgressEvent) => void, fileName?: string) => Promise<IImportMeshAsyncOutput>;
    loadAsync: (scene: Scene, data: IGLTFLoaderData, rootUrl: string, onProgress?: (event: SceneLoaderProgressEvent) => void, fileName?: string) => Promise<void>;
}
/**
 * File loader for loading glTF files into a scene.
 */
export declare class GLTFFileLoader implements IDisposable, ISceneLoaderPluginAsync, ISceneLoaderPluginFactory {
    /** @hidden */
    static _CreateGLTF1Loader: (parent: GLTFFileLoader) => IGLTFLoader;
    /** @hidden */
    static _CreateGLTF2Loader: (parent: GLTFFileLoader) => IGLTFLoader;
    /**
     * Raised when the asset has been parsed
     */
    onParsedObservable: Observable<IGLTFLoaderData>;
    private _onParsedObserver;
    /**
     * Raised when the asset has been parsed
     */
    set onParsed(callback: (loaderData: IGLTFLoaderData) => void);
    /**
     * Set this property to false to disable incremental loading which delays the loader from calling the success callback until after loading the meshes and shaders.
     * Textures always loads asynchronously. For example, the success callback can compute the bounding information of the loaded meshes when incremental loading is disabled.
     * Defaults to true.
     * @hidden
     */
    static IncrementalLoading: boolean;
    /**
     * Set this property to true in order to work with homogeneous coordinates, available with some converters and exporters.
     * Defaults to false. See https://en.wikipedia.org/wiki/Homogeneous_coordinates.
     * @hidden
     */
    static HomogeneousCoordinates: boolean;
    /**
     * The coordinate system mode. Defaults to AUTO.
     */
    coordinateSystemMode: GLTFLoaderCoordinateSystemMode;
    /**
    * The animation start mode. Defaults to FIRST.
    */
    animationStartMode: GLTFLoaderAnimationStartMode;
    /**
     * Defines if the loader should compile materials before raising the success callback. Defaults to false.
     */
    compileMaterials: boolean;
    /**
     * Defines if the loader should also compile materials with clip planes. Defaults to false.
     */
    useClipPlane: boolean;
    /**
     * Defines if the loader should compile shadow generators before raising the success callback. Defaults to false.
     */
    compileShadowGenerators: boolean;
    /**
     * Defines if the Alpha blended materials are only applied as coverage.
     * If false, (default) The luminance of each pixel will reduce its opacity to simulate the behaviour of most physical materials.
     * If true, no extra effects are applied to transparent pixels.
     */
    transparencyAsCoverage: boolean;
    /**
     * Defines if the loader should use range requests when load binary glTF files from HTTP.
     * Enabling will disable offline support and glTF validator.
     * Defaults to false.
     */
    useRangeRequests: boolean;
    /**
     * Defines if the loader should create instances when multiple glTF nodes point to the same glTF mesh. Defaults to true.
     */
    createInstances: boolean;
    /**
     * Function called before loading a url referenced by the asset.
     */
    preprocessUrlAsync: (url: string) => Promise<string>;
    /**
     * Observable raised when the loader creates a mesh after parsing the glTF properties of the mesh.
     */
    readonly onMeshLoadedObservable: Observable<AbstractMesh>;
    private _onMeshLoadedObserver;
    /**
     * Callback raised when the loader creates a mesh after parsing the glTF properties of the mesh.
     */
    set onMeshLoaded(callback: (mesh: AbstractMesh) => void);
    /**
     * Observable raised when the loader creates a texture after parsing the glTF properties of the texture.
     */
    readonly onTextureLoadedObservable: Observable<BaseTexture>;
    private _onTextureLoadedObserver;
    /**
     * Callback raised when the loader creates a texture after parsing the glTF properties of the texture.
     */
    set onTextureLoaded(callback: (texture: BaseTexture) => void);
    /**
     * Observable raised when the loader creates a material after parsing the glTF properties of the material.
     */
    readonly onMaterialLoadedObservable: Observable<Material>;
    private _onMaterialLoadedObserver;
    /**
     * Callback raised when the loader creates a material after parsing the glTF properties of the material.
     */
    set onMaterialLoaded(callback: (material: Material) => void);
    /**
     * Observable raised when the loader creates a camera after parsing the glTF properties of the camera.
     */
    readonly onCameraLoadedObservable: Observable<Camera>;
    private _onCameraLoadedObserver;
    /**
     * Callback raised when the loader creates a camera after parsing the glTF properties of the camera.
     */
    set onCameraLoaded(callback: (camera: Camera) => void);
    /**
     * Observable raised when the asset is completely loaded, immediately before the loader is disposed.
     * For assets with LODs, raised when all of the LODs are complete.
     * For assets without LODs, raised when the model is complete, immediately after the loader resolves the returned promise.
     */
    readonly onCompleteObservable: Observable<void>;
    private _onCompleteObserver;
    /**
     * Callback raised when the asset is completely loaded, immediately before the loader is disposed.
     * For assets with LODs, raised when all of the LODs are complete.
     * For assets without LODs, raised when the model is complete, immediately after the loader resolves the returned promise.
     */
    set onComplete(callback: () => void);
    /**
     * Observable raised when an error occurs.
     */
    readonly onErrorObservable: Observable<any>;
    private _onErrorObserver;
    /**
     * Callback raised when an error occurs.
     */
    set onError(callback: (reason: any) => void);
    /**
     * Observable raised after the loader is disposed.
     */
    readonly onDisposeObservable: Observable<void>;
    private _onDisposeObserver;
    /**
     * Callback raised after the loader is disposed.
     */
    set onDispose(callback: () => void);
    /**
     * Observable raised after a loader extension is created.
     * Set additional options for a loader extension in this event.
     */
    readonly onExtensionLoadedObservable: Observable<IGLTFLoaderExtension>;
    private _onExtensionLoadedObserver;
    /**
     * Callback raised after a loader extension is created.
     */
    set onExtensionLoaded(callback: (extension: IGLTFLoaderExtension) => void);
    /**
     * Defines if the loader logging is enabled.
     */
    get loggingEnabled(): boolean;
    set loggingEnabled(value: boolean);
    /**
     * Defines if the loader should capture performance counters.
     */
    get capturePerformanceCounters(): boolean;
    set capturePerformanceCounters(value: boolean);
    /**
     * Defines if the loader should validate the asset.
     */
    validate: boolean;
    /**
     * Observable raised after validation when validate is set to true. The event data is the result of the validation.
     */
    readonly onValidatedObservable: Observable<GLTF2.IGLTFValidationResults>;
    private _onValidatedObserver;
    /**
     * Callback raised after a loader extension is created.
     */
    set onValidated(callback: (results: GLTF2.IGLTFValidationResults) => void);
    private _loader;
    /**
     * Name of the loader ("gltf")
     */
    name: string;
    /** @hidden */
    extensions: ISceneLoaderPluginExtensions;
    /**
     * Disposes the loader, releases resources during load, and cancels any outstanding requests.
     */
    dispose(): void;
    /** @hidden */
    _clear(): void;
    /** @hidden */
    requestFile(scene: Scene, url: string, onSuccess: (data: any, request?: WebRequest) => void, onProgress?: (ev: ProgressEvent) => void, useArrayBuffer?: boolean, onError?: (error: any) => void): IFileRequest;
    /** @hidden */
    readFile(scene: Scene, file: File, onSuccess: (data: any) => void, onProgress?: (ev: ProgressEvent) => any, useArrayBuffer?: boolean, onError?: (error: any) => void): IFileRequest;
    /** @hidden */
    importMeshAsync(meshesNames: any, scene: Scene, data: any, rootUrl: string, onProgress?: (event: SceneLoaderProgressEvent) => void, fileName?: string): Promise<{
        meshes: AbstractMesh[];
        particleSystems: IParticleSystem[];
        skeletons: Skeleton[];
        animationGroups: AnimationGroup[];
    }>;
    /** @hidden */
    loadAsync(scene: Scene, data: any, rootUrl: string, onProgress?: (event: SceneLoaderProgressEvent) => void, fileName?: string): Promise<void>;
    /** @hidden */
    loadAssetContainerAsync(scene: Scene, data: any, rootUrl: string, onProgress?: (event: SceneLoaderProgressEvent) => void, fileName?: string): Promise<AssetContainer>;
    /** @hidden */
    canDirectLoad(data: string): boolean;
    /** @hidden */
    directLoad(scene: Scene, data: string): any;
    /**
     * The callback that allows custom handling of the root url based on the response url.
     * @param rootUrl the original root url
     * @param responseURL the response url if available
     * @returns the new root url
     */
    rewriteRootURL?(rootUrl: string, responseURL?: string): string;
    /** @hidden */
    createPlugin(): ISceneLoaderPlugin | ISceneLoaderPluginAsync;
    /**
     * The loader state or null if the loader is not active.
     */
    get loaderState(): Nullable<GLTFLoaderState>;
    /**
     * Returns a promise that resolves when the asset is completely loaded.
     * @returns a promise that resolves when the asset is completely loaded.
     */
    whenCompleteAsync(): Promise<void>;
    private _validate;
    private _getLoader;
    private _parseJson;
    private _unpackBinaryAsync;
    private _unpackBinaryV1Async;
    private _unpackBinaryV2Async;
    private static _parseVersion;
    private static _compareVersion;
    private static readonly _logSpaces;
    private _logIndentLevel;
    private _loggingEnabled;
    /** @hidden */
    _log: (message: string) => void;
    /** @hidden */
    _logOpen(message: string): void;
    /** @hidden */
    _logClose(): void;
    private _logEnabled;
    private _logDisabled;
    private _capturePerformanceCounters;
    /** @hidden */
    _startPerformanceCounter: (counterName: string) => void;
    /** @hidden */
    _endPerformanceCounter: (counterName: string) => void;
    private _startPerformanceCounterEnabled;
    private _startPerformanceCounterDisabled;
    private _endPerformanceCounterEnabled;
    private _endPerformanceCounterDisabled;
}
